using NLsolve, Plots, Parameters, Distributions, Statistics, StatsPlots
include("discrete_normal.jl")
include("lininterp1.jl")

@with_kw struct Calibration
    #Households
    σ::Float64=0.5                      # elasticity of relative demand with respect to price sigma=0.5 completementary goods
    ζ::Float64=2.0                      # Intertemporal elasticity of substitution
    θ::Float64=1/ζ                      # Inverse of intertemporal elasticity of substitution 
    γ::Array{Float64}=[1/3, 1/3, 1/3]   # intensity in each good
    ϵ::Array{Float64}=[0.6, 1.0, 1.65]  # elasticity of relative demand with respect to income in luxury good sector
    ρ::Float64 =(σ-1)/σ                 
    β::Float64 = 0.96                   # Discount factor

    #Production
    α::Float64=0.4                      # Capital share
    δ::Float64=0.1                      # Capital depreciation
    Z::Array{Float64}=[0.9, 1.0, 1.2]   # Sector productivity
end

cal = Calibration()

#intratemporal utility 
#NH Utility Function
function solvingNH(u, r::Float64, w::Float64, a::Float64, y::Float64, p_c::Vector{Float64}; cal=cal)
    @unpack σ, ζ, γ, ϵ, ρ, β, α, δ, Z = cal

    E=r.*a.+w.*y
    out=1-sum(γ[i]^(1/σ)*(((p_c[i]/E)^(-σ)*γ[i])/u^((1-σ)*σ*ϵ[i]))^ρ for i=1:length(p_c))
    
    return out
end

#Intratemporal utility with composite consumption bundle (C1,...,CI)=C
function NHUtility(r::Float64, w::Float64, a::Float64, y::Float64, p_c::Vector{Float64}; cal=cal)
    @unpack σ, ζ, γ, ϵ, ρ, β, α, δ, Z = cal

    #Utility level for given C endowment
    res = nlsolve(u->[solvingNH(u[1], r, w, a, y, p_c)], [1.0])
    U=res.zero[1]

    #Wealth and Minimum expenditure for the utility at given endowment level
    E=r.*a.+w.*y
    ExpNH=sum(γ[i]*U^(ϵ[i]*(1-σ)^2) * (p_c[i]^(1-σ)) for i = 1:length(p_c))^(1/(1-σ))
    
    #Optimal Demand with income effect
    C1=γ[1]*U^(ϵ[1]*(1-σ)^2) * (p_c[1]/E)^(-σ)
    C2=γ[2]*U^(ϵ[2]*(1-σ)^2) * (p_c[2]/E)^(-σ)
    C3=γ[3]*U^(ϵ[3]*(1-σ)^2) * (p_c[3]/E)^(-σ)

    #Expenditure share with income effect
    ω_p=γ[1]*U^(ϵ[1]*(1-σ)^2) * (p_c[1]/E)^(1-σ)
    ω_n=γ[2]*U^(ϵ[2]*(1-σ)^2) * (p_c[2]/E)^(1-σ)
    ω_l=γ[3]*U^(ϵ[3]*(1-σ)^2) * (p_c[3]/E)^(1-σ)

    ω=[ω_p ω_n ω_l]
    return [C1, C2, C3, U, E, ω]#, U, E, ω]

end



#Intertemporal utility
@unpack σ, ζ, θ, γ, ϵ, ρ, β, α, δ, Z = cal
if θ==1
    u(c) = log.(c)
else
    u(c) = (c.^(1-θ).-1)./(1-θ)
end 

u1(c) = c.^(-θ)
u1inv(u) = u.^(-1 ./(θ))

## income risk: discretized N(mu,sigma^2)
mu_y = 1
sd_y = 0.2
ny = 10

## asset grids
na = 40
amax = 50
borrow_lim = 0
agrid_par = 0.5 # 1 for linear, 0 for L-shaped

## computation
max_iter = 1000
tol_iter = 1.0e-6
Nsim = 50000
Tsim = 500

maxiter_KL = 70
tol_KL = 1.0e-2
step_KL = 0.005
rguess = 1/β-1-0.001 # a bit lower than inverse of discount rate
KLratioguess = ((rguess + δ)/α)^(1/(α-1))

# SET UP GRIDS

## assets
agrid = range(0,1,length=na)
agrid = agrid.^(1 ./ agrid_par)
agrid = borrow_lim .+ (amax.-borrow_lim).*agrid

## income: disretize normal distribution
width = nlsolve(x -> discrete_normal(ny,mu_y,sd_y,x...)[1],[2.0]).zero
temp, ygrid, ydist = discrete_normal(ny,mu_y,sd_y,width...)
ycumdist = cumsum(ydist)

# DRAW RANDOM NUMBERS
yrand = rand(Nsim,Tsim)
yindsim = zeros(Int,Nsim,Tsim)
    
for it = 1:Tsim

    # income realization: note we vectorize simulations at once because
    # of matlab, in other languages we would loop over individuals
    yindsim[yrand[:,it].<=ycumdist[1],it] .= 1
    for iy = 2:ny
        yindsim[(yrand[:,it].>ycumdist[iy-1]) .& (yrand[:,it].<=ycumdist[iy]),it] .= iy;
    end
end
    
ysim = ygrid[yindsim]

KLratio = KLratioguess
r = α.*KLratio^(α-1) - δ
R = 1+r
wage = (1-α).* KLratio^α

C1=[]
C2=[]
C3=[]
U=[]
E=[]
p=[1.25,1.5,2.0]
for i = 1:na
    for j=1:ny
        C1=push!(C1, NHUtility(r, wage, agrid[i], ygrid[j], p)[1])
        C2=push!(C2,NHUtility(r, wage, agrid[i], ygrid[j], p)[2])
        C3=push!(C3,NHUtility(r, wage, agrid[i], ygrid[j], p)[3])
        U=push!(U,NHUtility(r, wage, agrid[i], ygrid[j], p)[4])
        E=push!(E,NHUtility(r, wage, agrid[i], ygrid[j], p)[5])
    end
end

D=[C1 C2 C3 U E]
D=sortslices(D,dims=1,by=x->(x[5]),rev=false)
C=D[:,[1,2,3]]


conguess = zeros(na*ny)
for iy = 1:ny
    conguess[:,iy] = NHUtility(r, wage, agrid[i], ygrid[j], p)[5]

end



function solvingNHcash(u, cash::Float64, p_c::Vector{Float64}; cal=cal)
    @unpack σ, ζ, γ, ϵ, ρ, β, α, δ, Z = cal
    out=1-sum(γ[i]^(1/σ)*(((p_c[i]/cash)^(-σ)*γ[i])/u^((1-σ)*σ*ϵ[i]))^ρ for i=1:length(p_c))
    return out
end



if InterpCon==1
    fn_eeqn_c(a) = u1(NHUtility(r, wage, agrid[10], ygrid[10], p)[5]-a)-beta.*R.*(u1([lininterp1(agrid,conlast[:,iy],a) for iy=1:ny])'*ydist)[1]
end

cash=r*agrid[10]+wage*ygrid[10]

U=[]
for i=1:na
    U=push!(U,NHUtility(r, wage, agrid[i], ygrid[10], p)[4])
end

for i = 1:na
    cash=r*agrid[i]+wage*ygrid[10]
    fn_eeqn_c(sav)=u1(nlsolve(u->[solvingNHcash(u[1], cash-sav, p)], [1.0]).zero[1])-β*R*u1(interpolate((agrid,),U, Gridded(Linear())))[2]
    saving = nlsolve(x -> fn_eeqn_c(x...), [1.0]).zero[1]
    println("saving:", saving, "cash:", cash)
end
a

TolX = 1.0e-6



β*R*u1(interpolate((agrid,),U, Gridded(Linear())))[1]


interpolate((agrid,),U, Gridded(Linear()))
u1(nlsolve(u->[solvingNHcash(u[1], cash-1.0, p)], [1.0]).zero[1])

nlsolve(u->[solvingNHcash(u[1], cash-0.5, p)], [1.0]).zero[1]

